<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NN Visualization Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #eee;
            --text-secondary: #bbb;
            --accent: #4a4a4a;
            --success: #00c853;
            --warning: #ffc107;
            --danger: #ff5252;
            --info: #00bcd4;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 16px;
            min-height: 100vh;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--accent);
            flex-wrap: wrap;
            gap: 12px;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
        }

        .header-info {
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: var(--text-secondary);
            align-items: center;
            flex-wrap: wrap;
        }

        .header-info strong {
            color: var(--text-primary);
        }

        .refresh-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .countdown {
            font-family: 'Courier New', monospace;
            background: var(--accent);
            padding: 4px 10px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
        }

        .btn {
            background: var(--accent);
            color: var(--text-primary);
            border: none;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: opacity 0.2s;
        }

        .btn:hover { opacity: 0.8; }

        #lastUpdated {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        #lastUpdated.error { color: var(--danger); }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 16px;
        }

        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 800px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }

        .section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 14px;
        }

        .section h2 {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--accent);
            color: #ccc;
        }

        .card {
            background: var(--bg-primary);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .card:last-child { margin-bottom: 0; }

        .card h3 {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .stat-card {
            background: var(--bg-primary);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 22px;
            font-weight: bold;
            color: var(--info);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .heatmap-container {
            width: 100%;
            aspect-ratio: 1;
            margin-bottom: 8px;
        }

        #chunkHeatmap {
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }

        .decisions-table {
            width: 100%;
            font-size: 12px;
            border-collapse: collapse;
        }

        .decisions-table th,
        .decisions-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid var(--accent);
        }

        .decisions-table th {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .decisions-table tr:last-child td {
            border-bottom: none;
        }

        .gauge-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 8px;
        }

        .gauge-value {
            font-size: 28px;
            font-weight: bold;
            margin-top: 8px;
        }

        .gauge-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .wait-streak {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: var(--bg-primary);
            border-radius: 6px;
        }

        .wait-streak.warning {
            background: rgba(255, 82, 82, 0.15);
            border: 1px solid var(--danger);
        }

        .wait-streak-value {
            font-size: 20px;
            font-weight: bold;
        }

        .wait-streak.warning .wait-streak-value {
            color: var(--danger);
        }

        .chart-container {
            height: 140px;
            margin-bottom: 8px;
        }

        .chart-container.tall {
            height: 180px;
        }

        /* Entropy Display Styles */
        .entropy-display {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .entropy-bar-container {
            position: relative;
            height: 30px;
            background: linear-gradient(to right,
                var(--danger) 0%,
                var(--danger) 25%,
                var(--warning) 25%,
                var(--warning) 50%,
                var(--success) 50%,
                var(--success) 100%);
            border-radius: 4px;
            overflow: hidden;
        }

        .entropy-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 50%;
            background: rgba(255, 255, 255, 0.3);
            border-right: 3px solid white;
            transition: width 0.5s ease;
        }

        .entropy-zones {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            padding: 0 8px;
        }

        .entropy-zones .zone {
            flex: 1;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            opacity: 0.8;
        }

        .entropy-zones .zone.collapsed { color: #fff; }
        .entropy-zones .zone.warning { color: #000; }
        .entropy-zones .zone.healthy { color: #fff; }

        .entropy-value {
            display: flex;
            align-items: baseline;
            gap: 8px;
            justify-content: center;
        }

        .entropy-value #entropyRatio {
            font-size: 32px;
            font-weight: bold;
            color: var(--info);
        }

        .entropy-value .entropy-label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .entropy-explanation {
            font-size: 12px;
            line-height: 1.5;
        }

        .entropy-explanation p {
            margin-bottom: 8px;
        }

        .entropy-explanation ul {
            margin-left: 16px;
            margin-bottom: 8px;
        }

        .entropy-explanation li {
            margin-bottom: 4px;
        }

        #entropyHealth.healthy { color: var(--success); }
        #entropyHealth.warning { color: var(--warning); }
        #entropyHealth.collapsed { color: var(--danger); }

        .loading { opacity: 0.5; }

        .type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }

        .type-badge.energy {
            background: rgba(76, 175, 80, 0.3);
            color: #81c784;
        }

        .type-badge.combat {
            background: rgba(244, 67, 54, 0.3);
            color: #e57373;
        }

        .sent-badge {
            display: inline-block;
            width: 18px;
            text-align: center;
        }

        .sent-badge.yes { color: var(--success); }
        .sent-badge.no { color: var(--danger); }

        .time-info {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 6px;
        }

        /* Pipeline Visualization */
        .pipeline-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 14px;
            margin-bottom: 16px;
        }

        .pipeline-section h2 {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--accent);
            color: #ccc;
        }

        .pipeline-container {
            display: flex;
            align-items: stretch;
            gap: 6px;
            overflow-x: auto;
            padding-bottom: 8px;
        }

        .pipeline-stage {
            flex: 1;
            min-width: 130px;
            max-width: 180px;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 2px solid var(--accent);
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .pipeline-stage.decision-send {
            border-color: var(--success);
            box-shadow: 0 0 12px rgba(0, 200, 83, 0.3);
        }

        .pipeline-stage.decision-wait {
            border-color: var(--danger);
            box-shadow: 0 0 12px rgba(255, 82, 82, 0.3);
        }

        .stage-header {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--accent);
            letter-spacing: 0.5px;
        }

        .stage-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .stage-item {
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stage-item .label {
            color: var(--text-secondary);
        }

        .stage-item .value {
            font-weight: 500;
            color: var(--text-primary);
        }

        .stage-item small {
            color: var(--text-secondary);
            font-size: 9px;
            margin-left: 4px;
        }

        .stage-formula {
            font-size: 9px;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 6px;
            font-family: monospace;
        }

        .stage-value-large {
            font-size: 22px;
            font-weight: bold;
            text-align: center;
            color: var(--info);
        }

        .stage-decision {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 4px 0;
        }

        .stage-decision.send { color: var(--success); }
        .stage-decision.wait { color: var(--danger); }

        .stage-reason {
            font-size: 10px;
            text-align: center;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .pipeline-arrow {
            display: flex;
            align-items: center;
            font-size: 20px;
            color: var(--text-secondary);
            padding: 0 2px;
            flex-shrink: 0;
        }

        .rate-positive { color: var(--danger); }
        .rate-negative { color: var(--success); }

        @media (max-width: 900px) {
            .pipeline-container {
                flex-wrap: wrap;
                justify-content: center;
            }
            .pipeline-arrow {
                display: none;
            }
            .pipeline-stage {
                min-width: 140px;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>NN Visualization Dashboard</h1>
        <div class="header-info">
            <span>Territory: <strong id="territoryId">-</strong></span>
            <span>Uptime: <strong id="uptime">-</strong></span>
            <div class="refresh-indicator">
                <span>Next:</span>
                <span class="countdown" id="countdown">15</span>
                <button class="btn" onclick="refreshNow()">Refresh</button>
                <button class="btn" onclick="exportData()">Export</button>
            </div>
        </div>
    </div>

    <div id="lastUpdated">Last updated: Never</div>

    <!-- Pipeline Visualization -->
    <div class="pipeline-section">
        <h2>Simulation Gate Pipeline</h2>
        <div class="pipeline-container">
            <!-- Stage 1: Observation -->
            <div class="pipeline-stage" id="stage-observation">
                <div class="stage-header">OBSERVATION</div>
                <div class="stage-content">
                    <div class="stage-item"><span class="label">Workers</span><span class="value" id="pipe-workers">-</span></div>
                    <div class="stage-item"><span class="label">Protectors</span><span class="value" id="pipe-protectors">-</span></div>
                    <div class="stage-item"><span class="label">Parasites</span><span class="value" id="pipe-parasites">-</span></div>
                    <div class="stage-item"><span class="label">Q.Energy</span><span class="value" id="pipe-queen-energy">-</span></div>
                    <div class="stage-item"><span class="label">P.Energy Δ</span><span class="value" id="pipe-energy-rate">-</span></div>
                    <div class="stage-item"><span class="label">P.Mineral Δ</span><span class="value" id="pipe-mineral-rate">-</span></div>
                </div>
            </div>

            <div class="pipeline-arrow">→</div>

            <!-- Stage 2: NN Inference -->
            <div class="pipeline-stage" id="stage-nn-inference">
                <div class="stage-header">NN INFERENCE</div>
                <div class="stage-content">
                    <div class="stage-item"><span class="label">Decision</span><span class="value" id="pipe-nn-decision">-</span></div>
                    <div class="stage-item"><span class="label">Chunk</span><span class="value" id="pipe-chunk">-</span></div>
                    <div class="stage-item"><span class="label">Type</span><span class="value" id="pipe-type">-</span></div>
                    <div class="stage-item"><span class="label">Confidence</span><span class="value" id="pipe-confidence">-</span></div>
                </div>
            </div>

            <div class="pipeline-arrow">→</div>

            <!-- Stage 3: Gate Components -->
            <div class="pipeline-stage" id="stage-components">
                <div class="stage-header">GATE COMPONENTS</div>
                <div class="stage-content">
                    <div class="stage-item"><span class="label">Capacity</span><span class="value" id="pipe-capacity">-</span></div>
                    <div class="stage-item"><span class="label">Survival</span><span class="value" id="pipe-survival">-</span><small>(w=0.4)</small></div>
                    <div class="stage-item"><span class="label">Disruption</span><span class="value" id="pipe-disruption">-</span><small>(w=0.5)</small></div>
                    <div class="stage-item"><span class="label">Location</span><span class="value" id="pipe-location">-</span><small>(w=0.1)</small></div>
                    <div class="stage-item"><span class="label">Exploration</span><span class="value" id="pipe-exploration">-</span></div>
                </div>
            </div>

            <div class="pipeline-arrow">→</div>

            <!-- Stage 4: Combined Reward -->
            <div class="pipeline-stage" id="stage-combined">
                <div class="stage-header">COMBINED</div>
                <div class="stage-content" style="justify-content: center;">
                    <div class="stage-formula">R = V×(w₁S + w₂D + w₃L) + E</div>
                    <div class="stage-value-large" id="pipe-expected-reward">-</div>
                </div>
            </div>

            <div class="pipeline-arrow">→</div>

            <!-- Stage 5: Decision -->
            <div class="pipeline-stage" id="stage-decision">
                <div class="stage-header">DECISION</div>
                <div class="stage-content" style="justify-content: center;">
                    <div class="stage-decision" id="pipe-decision">-</div>
                    <div class="stage-reason" id="pipe-reason">-</div>
                </div>
            </div>
        </div>
    </div>

    <div class="dashboard">
        <!-- NN Decisions Section -->
        <div class="section">
            <h2>NN Decisions</h2>

            <div class="card">
                <h3>Chunk Heatmap (16x16 = 256 spawn chunks)</h3>
                <div class="heatmap-container">
                    <canvas id="chunkHeatmap"></canvas>
                </div>
                <div style="display: flex; gap: 12px; font-size: 10px; color: var(--text-secondary); margin-top: 6px; flex-wrap: wrap;">
                    <span><span style="color: #4caf50;">●</span> Workers</span>
                    <span><span style="color: #f44336;">■</span> Protectors</span>
                    <span><span style="color: #ffeb3b;">◆</span> Parasites</span>
                    <span><span style="color: #00bcd4;">□</span> Sent</span>
                    <span><span style="color: #ff5252;">□</span> Skipped</span>
                </div>
            </div>

            <div class="card">
                <h3>Recent Decisions</h3>
                <table class="decisions-table">
                    <thead>
                        <tr><th>Chunk</th><th>Type</th><th>Conf</th><th>Sent</th></tr>
                    </thead>
                    <tbody id="decisionsTable">
                        <tr><td colspan="4" style="text-align: center; color: var(--text-secondary);">No data</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="stat-grid">
                <div class="stat-card">
                    <div class="stat-value" id="energyCount">0</div>
                    <div class="stat-label">Energy Spawns</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="combatCount">0</div>
                    <div class="stat-label">Combat Spawns</div>
                </div>
            </div>

            <div class="card">
                <h3>Confidence Distribution</h3>
                <div class="chart-container">
                    <canvas id="confidenceChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Training Section -->
        <div class="section">
            <h2>Training Progress</h2>

            <div class="stat-grid">
                <div class="stat-card">
                    <div class="stat-value" id="modelVersion">0</div>
                    <div class="stat-label">NN Version</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="bufferSize">0</div>
                    <div class="stat-label">Buffer Size</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgLoss">-</div>
                    <div class="stat-label">Avg Loss</div>
                </div>
            </div>

            <div class="card">
                <h3>Loss Curve</h3>
                <div class="chart-container tall">
                    <canvas id="lossChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h3>Reward History (Sim vs Real)</h3>
                <div class="chart-container tall">
                    <canvas id="rewardsChart"></canvas>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-value" id="avgReward">-</div>
                <div class="stat-label">Average Reward</div>
            </div>
        </div>

        <!-- Entropy Section (Distribution Health) -->
        <div class="section">
            <h2>Distribution Health (Entropy)</h2>

            <div class="card">
                <h3>Entropy Status</h3>
                <div class="entropy-display">
                    <div class="entropy-bar-container">
                        <div class="entropy-bar" id="entropyBar"></div>
                        <div class="entropy-zones">
                            <span class="zone collapsed">Collapsed</span>
                            <span class="zone warning">Warning</span>
                            <span class="zone healthy">Healthy</span>
                        </div>
                    </div>
                    <div class="entropy-value">
                        <span id="entropyRatio">-</span>
                        <span class="entropy-label">of maximum</span>
                    </div>
                </div>
            </div>

            <div class="stat-grid">
                <div class="stat-card">
                    <div class="stat-value" id="entropyValue">-</div>
                    <div class="stat-label">Current Entropy</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="maxEntropy">-</div>
                    <div class="stat-label">Max Entropy</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="effectiveActions">-</div>
                    <div class="stat-label">Effective Actions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="entropyHealth">-</div>
                    <div class="stat-label">Health Status</div>
                </div>
            </div>

            <div class="card">
                <h3>Entropy History</h3>
                <div class="chart-container tall">
                    <canvas id="entropyChart"></canvas>
                </div>
            </div>

            <div class="card entropy-explanation">
                <h3>What is Entropy?</h3>
                <p><strong>Entropy</strong> measures how spread out the NN's probability distribution is.</p>
                <ul>
                    <li><strong>High entropy (healthy)</strong>: NN considers many chunks → good exploration</li>
                    <li><strong>Low entropy (collapsed)</strong>: NN stuck on few chunks → no learning</li>
                </ul>
                <p><strong>Effective Actions</strong>: How many chunks the NN effectively considers (higher = better)</p>
            </div>
        </div>
    </div>

    <script>
        // Dashboard state
        let dashboardData = null;
        let refreshInterval = 5000;
        let countdownValue = 15;
        let countdownTimer = null;
        let charts = {};

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeCharts();
            fetchDashboardData();
            startRefreshCycle();
        });

        function initializeCharts() {
            const chartDefaults = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                }
            };

            // Confidence Histogram
            charts.confidence = new Chart(
                document.getElementById('confidenceChart').getContext('2d'),
                {
                    type: 'bar',
                    data: {
                        labels: ['0.0', '0.1', '0.2', '0.3', '0.4', '0.5', '0.6', '0.7', '0.8', '0.9'],
                        datasets: [{
                            label: 'Count',
                            data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            backgroundColor: 'rgba(0, 188, 212, 0.6)',
                            borderColor: 'rgba(0, 188, 212, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        ...chartDefaults,
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { ticks: { color: '#aaa' }, grid: { display: false } }
                        }
                    }
                }
            );

            // Loss Curve
            charts.loss = new Chart(
                document.getElementById('lossChart').getContext('2d'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Loss',
                            data: [],
                            borderColor: '#f44336',
                            backgroundColor: 'rgba(244, 67, 54, 0.1)',
                            tension: 0.3,
                            fill: true,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        ...chartDefaults,
                        scales: {
                            y: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { display: false }
                        }
                    }
                }
            );

            // Rewards Comparison (Sim vs Real)
            charts.rewards = new Chart(
                document.getElementById('rewardsChart').getContext('2d'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Simulation',
                                data: [],
                                borderColor: '#2196f3',
                                tension: 0.3,
                                fill: false,
                                pointRadius: 0
                            },
                            {
                                label: 'Real',
                                data: [],
                                borderColor: '#4caf50',
                                tension: 0.3,
                                fill: false,
                                pointRadius: 0
                            }
                        ]
                    },
                    options: {
                        ...chartDefaults,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: { color: '#aaa', font: { size: 10 }, boxWidth: 12 }
                            }
                        },
                        scales: {
                            y: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { display: false }
                        }
                    }
                }
            );

            // Entropy History Chart
            charts.entropy = new Chart(
                document.getElementById('entropyChart').getContext('2d'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Entropy',
                            data: [],
                            borderColor: '#00bcd4',
                            backgroundColor: 'rgba(0, 188, 212, 0.1)',
                            tension: 0.3,
                            fill: true,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        ...chartDefaults,
                        scales: {
                            y: {
                                min: 0,
                                max: 6,  // Slightly above max entropy (~5.55)
                                ticks: { color: '#aaa' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            x: { display: false }
                        },
                        plugins: {
                            annotation: {
                                annotations: {
                                    healthyLine: {
                                        type: 'line',
                                        yMin: 2.77,  // 50% of max
                                        yMax: 2.77,
                                        borderColor: 'rgba(0, 200, 83, 0.5)',
                                        borderWidth: 1,
                                        borderDash: [5, 5]
                                    },
                                    warningLine: {
                                        type: 'line',
                                        yMin: 1.39,  // 25% of max
                                        yMax: 1.39,
                                        borderColor: 'rgba(255, 193, 7, 0.5)',
                                        borderWidth: 1,
                                        borderDash: [5, 5]
                                    }
                                }
                            }
                        }
                    }
                }
            );
        }

        async function fetchDashboardData() {
            const container = document.querySelector('.dashboard');
            container.classList.add('loading');

            try {
                const response = await fetch('/api/nn-dashboard');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                dashboardData = await response.json();
                updateDashboard(dashboardData);

                document.getElementById('lastUpdated').textContent =
                    `Last updated: ${new Date().toLocaleTimeString()}`;
                document.getElementById('lastUpdated').classList.remove('error');
            } catch (error) {
                console.error('Failed to fetch dashboard data:', error);
                document.getElementById('lastUpdated').textContent =
                    `Connection lost - retrying... (${error.message})`;
                document.getElementById('lastUpdated').classList.add('error');
            } finally {
                container.classList.remove('loading');
            }
        }

        function updateDashboard(data) {
            // Header info
            document.getElementById('territoryId').textContent =
                data.game_state?.territory_id || '-';
            document.getElementById('uptime').textContent =
                formatUptime(data.uptime_seconds);

            // Pipeline Visualization
            updatePipeline(data.pipeline);

            // NN Decisions - pass entity positions from pipeline observation
            const obs = data.pipeline?.observation || {};
            updateHeatmap(
                data.nn_decisions.chunk_sent,
                data.nn_decisions.chunk_skipped,
                obs.worker_chunks || [],
                obs.protector_chunks || [],
                obs.parasite_chunks || []
            );
            updateDecisionsTable(data.nn_decisions.recent_decisions);
            document.getElementById('energyCount').textContent =
                data.nn_decisions.type_counts.energy || 0;
            document.getElementById('combatCount').textContent =
                data.nn_decisions.type_counts.combat || 0;

            charts.confidence.data.datasets[0].data = data.nn_decisions.confidence_histogram;
            charts.confidence.update('none');

            // Training
            document.getElementById('modelVersion').textContent = data.training.model_version || 0;
            document.getElementById('bufferSize').textContent = data.training.buffer_size || 0;
            document.getElementById('avgLoss').textContent =
                formatDecimal(data.training.avg_loss, 4);
            document.getElementById('avgReward').textContent =
                formatDecimal(data.training.avg_reward, 4);

            const lossHist = data.training.loss_history || [];
            charts.loss.data.labels = lossHist.map((_, i) => i);
            charts.loss.data.datasets[0].data = lossHist;
            charts.loss.update('none');

            const simRewards = data.training.simulation_rewards || [];
            const realRewards = data.training.real_rewards || [];
            const maxLen = Math.max(simRewards.length, realRewards.length, 1);
            charts.rewards.data.labels = Array.from({ length: maxLen }, (_, i) => i);
            charts.rewards.data.datasets[0].data = simRewards;
            charts.rewards.data.datasets[1].data = realRewards;
            charts.rewards.update('none');

            // Entropy (Distribution Health)
            const entropy = data.entropy || {};
            const entropyRatio = entropy.ratio || 0;
            const entropyHealth = entropy.health || 'unknown';

            // Update entropy bar position (0-100%)
            document.getElementById('entropyBar').style.width = `${entropyRatio * 100}%`;

            // Update entropy ratio display
            document.getElementById('entropyRatio').textContent = `${(entropyRatio * 100).toFixed(1)}%`;

            // Update entropy stats
            document.getElementById('entropyValue').textContent = formatDecimal(entropy.current, 3);
            document.getElementById('maxEntropy').textContent = formatDecimal(entropy.max, 3);
            document.getElementById('effectiveActions').textContent =
                `${formatDecimal(entropy.effective_actions, 1)} / ${entropy.total_actions || 257}`;

            // Update health status with color
            const healthEl = document.getElementById('entropyHealth');
            healthEl.textContent = entropyHealth.toUpperCase();
            healthEl.className = `stat-value ${entropyHealth}`;

            // Update entropy history chart
            const entropyHist = entropy.history || [];
            charts.entropy.data.labels = entropyHist.map((_, i) => i);
            charts.entropy.data.datasets[0].data = entropyHist;
            charts.entropy.update('none');
        }

        function updateHeatmap(sentFrequencies, skippedFrequencies, workerChunks, protectorChunks, parasiteChunks) {
            const canvas = document.getElementById('chunkHeatmap');
            const ctx = canvas.getContext('2d');
            const gridSize = 16;  // 16x16 = 256 spawn chunks (NN outputs 0-255)

            // Set canvas size based on container
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            const cellWidth = canvas.width / gridSize;
            const cellHeight = canvas.height / gridSize;

            // Find max for color scaling (use max of both for consistent scaling)
            // Only consider first 256 elements (valid spawn chunks)
            const validSent = (sentFrequencies || []).slice(0, 256);
            const validSkipped = (skippedFrequencies || []).slice(0, 256);
            const maxSent = Math.max(...validSent, 1);
            const maxSkipped = Math.max(...validSkipped, 1);
            const maxFreq = Math.max(maxSent, maxSkipped);

            // Clear canvas
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid (16x16 = 256 chunks)
            for (let z = 0; z < gridSize; z++) {
                for (let x = 0; x < gridSize; x++) {
                    const chunkId = z * gridSize + x;
                    const sent = (sentFrequencies && sentFrequencies[chunkId]) || 0;
                    const skipped = (skippedFrequencies && skippedFrequencies[chunkId]) || 0;

                    if (sent > 0 || skipped > 0) {
                        // Determine dominant color based on sent vs skipped ratio
                        const total = sent + skipped;
                        const sentRatio = sent / total;
                        const intensity = total / maxFreq;

                        if (sentRatio >= 0.5) {
                            // More sent than skipped: Blue/Cyan gradient
                            const r = Math.floor(intensity * 50);
                            const g = Math.floor(intensity * 180 + 50);
                            const b = Math.floor(intensity * 155 + 100);
                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        } else {
                            // More skipped than sent: Red gradient
                            const r = Math.floor(intensity * 155 + 100);
                            const g = Math.floor(intensity * 50);
                            const b = Math.floor(intensity * 50);
                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        }
                    } else {
                        ctx.fillStyle = '#2d2d2d';
                    }

                    ctx.fillRect(
                        x * cellWidth + 0.5,
                        z * cellHeight + 0.5,
                        cellWidth - 1,
                        cellHeight - 1
                    );
                }
            }

            // Draw entity markers on top of heatmap
            const markerRadius = Math.min(cellWidth, cellHeight) * 0.3;

            // Draw workers (green circles)
            if (workerChunks && workerChunks.length > 0) {
                ctx.fillStyle = '#4caf50';
                ctx.strokeStyle = '#1e1e1e';
                ctx.lineWidth = 1;
                for (const chunkId of workerChunks) {
                    if (chunkId >= 0 && chunkId < gridSize * gridSize) {
                        const x = (chunkId % gridSize) * cellWidth + cellWidth / 2;
                        const z = Math.floor(chunkId / gridSize) * cellHeight + cellHeight / 2;
                        ctx.beginPath();
                        ctx.arc(x, z, markerRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }

            // Draw protectors (red squares)
            if (protectorChunks && protectorChunks.length > 0) {
                ctx.fillStyle = '#f44336';
                ctx.strokeStyle = '#1e1e1e';
                ctx.lineWidth = 1;
                for (const chunkId of protectorChunks) {
                    if (chunkId >= 0 && chunkId < gridSize * gridSize) {
                        const x = (chunkId % gridSize) * cellWidth + cellWidth / 2;
                        const z = Math.floor(chunkId / gridSize) * cellHeight + cellHeight / 2;
                        ctx.fillRect(x - markerRadius, z - markerRadius, markerRadius * 2, markerRadius * 2);
                        ctx.strokeRect(x - markerRadius, z - markerRadius, markerRadius * 2, markerRadius * 2);
                    }
                }
            }

            // Draw parasites (yellow diamonds)
            if (parasiteChunks && parasiteChunks.length > 0) {
                ctx.fillStyle = '#ffeb3b';
                ctx.strokeStyle = '#1e1e1e';
                ctx.lineWidth = 1;
                for (const chunkId of parasiteChunks) {
                    if (chunkId >= 0 && chunkId < gridSize * gridSize) {
                        const x = (chunkId % gridSize) * cellWidth + cellWidth / 2;
                        const z = Math.floor(chunkId / gridSize) * cellHeight + cellHeight / 2;
                        ctx.beginPath();
                        ctx.moveTo(x, z - markerRadius);
                        ctx.lineTo(x + markerRadius, z);
                        ctx.lineTo(x, z + markerRadius);
                        ctx.lineTo(x - markerRadius, z);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }
        }

        function updateDecisionsTable(decisions) {
            const tbody = document.getElementById('decisionsTable');

            if (!decisions || decisions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-secondary);">No data</td></tr>';
                return;
            }

            tbody.innerHTML = decisions.slice().reverse().map(d => `
                <tr>
                    <td>${d.chunk}</td>
                    <td><span class="type-badge ${d.type}">${d.type === 'energy' ? 'E' : 'C'}</span></td>
                    <td>${formatDecimal(d.confidence, 4)}</td>
                    <td><span class="sent-badge ${d.sent ? 'yes' : 'no'}">${d.sent ? '✓' : '✗'}</span></td>
                </tr>
            `).join('');
        }

        function startRefreshCycle() {
            countdownValue = refreshInterval / 1000;
            updateCountdown();

            countdownTimer = setInterval(() => {
                countdownValue--;
                updateCountdown();

                if (countdownValue <= 0) {
                    fetchDashboardData();
                    countdownValue = refreshInterval / 1000;
                }
            }, 1000);
        }

        function updateCountdown() {
            document.getElementById('countdown').textContent = countdownValue;
        }

        function refreshNow() {
            countdownValue = refreshInterval / 1000;
            fetchDashboardData();
        }

        function exportData() {
            if (!dashboardData) {
                alert('No data available to export');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `nn-dashboard-${timestamp}.json`;
            const blob = new Blob([JSON.stringify(dashboardData, null, 2)], { type: 'application/json' });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function formatUptime(seconds) {
            if (!seconds) return '-';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }

        function formatDuration(seconds) {
            if (!seconds) return '0s';
            if (seconds < 60) return `${Math.round(seconds)}s`;
            const mins = Math.floor(seconds / 60);
            const secs = Math.round(seconds % 60);
            return `${mins}m ${secs}s`;
        }

        function updatePipeline(pipeline) {
            if (!pipeline) {
                // No pipeline data yet - show placeholder
                return;
            }

            // Stage 1: Observation
            const obs = pipeline.observation || {};
            document.getElementById('pipe-workers').textContent = obs.workers_count ?? '-';
            document.getElementById('pipe-protectors').textContent = obs.protectors_count ?? '-';
            document.getElementById('pipe-parasites').textContent = obs.parasites_count ?? '-';
            document.getElementById('pipe-queen-energy').textContent = formatDecimal(obs.queen_energy, 4);

            const energyRateEl = document.getElementById('pipe-energy-rate');
            energyRateEl.textContent = formatRate(obs.player_energy_rate);
            energyRateEl.className = 'value ' + (obs.player_energy_rate > 0 ? 'rate-positive' : obs.player_energy_rate < 0 ? 'rate-negative' : '');

            const mineralRateEl = document.getElementById('pipe-mineral-rate');
            mineralRateEl.textContent = formatRate(obs.player_mineral_rate);
            mineralRateEl.className = 'value ' + (obs.player_mineral_rate > 0 ? 'rate-positive' : obs.player_mineral_rate < 0 ? 'rate-negative' : '');

            // Stage 2: NN Inference
            const nn = pipeline.nn_inference || {};
            const nnDecision = nn.nn_decision || 'spawn';
            
            // Display NN decision
            document.getElementById('pipe-nn-decision').textContent = nnDecision.toUpperCase();
            
            // Handle no-spawn display
            if (nnDecision === 'no_spawn') {
                document.getElementById('pipe-chunk').textContent = 'N/A';
                document.getElementById('pipe-type').textContent = 'N/A';
            } else {
                document.getElementById('pipe-chunk').textContent = nn.chunk_id ?? '-';
                document.getElementById('pipe-type').textContent = nn.spawn_type ?? '-';
            }
            document.getElementById('pipe-confidence').textContent = formatDecimal(nn.confidence, 4);

            // Stage 3: Gate Components
            const comp = pipeline.gate_components || {};
            const decision = pipeline.decision || {};
            // Capacity is OK unless reason is insufficient_energy
            const capacityEl = document.getElementById('pipe-capacity');
            const capacityOk = decision.reason !== 'insufficient_energy';
            capacityEl.textContent = capacityOk ? 'OK' : 'LOW';
            capacityEl.style.color = capacityOk ? 'var(--success)' : 'var(--danger)';
            document.getElementById('pipe-survival').textContent = formatDecimal(comp.survival, 4);
            document.getElementById('pipe-disruption').textContent = formatDecimal(comp.disruption, 4);
            document.getElementById('pipe-location').textContent = formatDecimal(comp.location, 4);
            document.getElementById('pipe-exploration').textContent = formatDecimal(comp.exploration, 4);

            // Stage 4: Combined Reward
            const combined = pipeline.combined_reward || {};
            document.getElementById('pipe-expected-reward').textContent =
                formatDecimal(combined.expected_reward, 4);

            // Stage 5: Decision (decision already defined above for capacity check)
            const decisionEl = document.getElementById('pipe-decision');
            const reasonEl = document.getElementById('pipe-reason');
            const stageEl = document.getElementById('stage-decision');

            if (nnDecision === 'no_spawn') {
                // Handle no-spawn decision display
                if (decision.action === 'CORRECT_WAIT') {
                    decisionEl.textContent = 'CORRECT';
                    decisionEl.className = 'stage-decision send'; // Green
                    stageEl.classList.remove('decision-send', 'decision-wait');
                    stageEl.classList.add('decision-send');
                } else if (decision.action === 'SHOULD_SPAWN') {
                    decisionEl.textContent = 'SHOULD SPAWN';
                    decisionEl.className = 'stage-decision wait'; // Red
                    stageEl.classList.remove('decision-send', 'decision-wait');
                    stageEl.classList.add('decision-wait');
                } else {
                    decisionEl.textContent = decision.action || '-';
                    decisionEl.className = 'stage-decision';
                    stageEl.classList.remove('decision-send', 'decision-wait');
                }
            } else {
                // Handle spawn decision display
                decisionEl.textContent = decision.action || '-';
                decisionEl.className = 'stage-decision ' + (decision.action?.toLowerCase() || '');
                
                // Update stage border color
                stageEl.classList.remove('decision-send', 'decision-wait');
                if (decision.action === 'SEND') {
                    stageEl.classList.add('decision-send');
                } else if (decision.action === 'WAIT') {
                    stageEl.classList.add('decision-wait');
                }
            }
            
            reasonEl.textContent = formatReason(decision.reason);
        }

        function formatDecimal(value, maxDecimals = 4) {
            if (value == null || isNaN(value)) return '-';
            // Use at most maxDecimals, but trim trailing zeros
            const fixed = Number(value).toFixed(maxDecimals);
            return parseFloat(fixed).toString();
        }

        function formatRate(rate) {
            if (rate == null) return '-';
            const sign = rate >= 0 ? '+' : '';
            return sign + formatDecimal(rate * 100, 2) + '%';
        }

        function formatReason(reason) {
            if (!reason) return '-';
            const labels = {
                'positive_reward': 'Positive Reward',
                'confidence_override': 'High Confidence',
                'negative_reward': 'Negative Reward',
                'insufficient_energy': 'Low Energy'
            };
            return labels[reason] || reason;
        }
    </script>
</body>
</html>
